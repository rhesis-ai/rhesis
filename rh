#!/bin/bash

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
NC='\033[0m' # No Color

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Function to display help
show_help() {
    echo -e "${CYAN}"
    echo "  ____  _   _ _____ ____ ___ ____  "
    echo " |  _ \| | | | ____/ ___|_ _/ ___| "
    echo " | |_) | |_| |  _| \___ \| |\___ \ "
    echo " |  _ <|  _  | |___ ___) | | ___) |"
    echo " |_| \_\_| |_|_____|____/___|____/ "
    echo -e "${NC}"
    echo ""
    echo -e "${WHITE}Rhesis CLI - Development Server Manager${NC}"
    echo -e "${PURPLE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo ""
    echo -e "${YELLOW}Usage:${NC}"
    echo -e "  ${GREEN}./rh start${NC}           - Start all services with Docker (zero-config)"
    echo -e "  ${GREEN}./rh dev${NC}             - Setup local dev environment (postgres:11000, redis:11001)"
    echo -e "  ${GREEN}./rh stop${NC}            - Stop all Docker services"
    echo -e "  ${GREEN}./rh restart${NC}         - Restart all Docker services"
    echo -e "  ${GREEN}./rh logs${NC}            - View logs from all services"
    echo -e "  ${GREEN}./rh delete${NC}          - Delete all services, images, volumes, and data"
    echo -e "  ${GREEN}./rh backend start${NC}   - Start the backend server (local)"
    echo -e "  ${GREEN}./rh frontend start${NC}  - Start the frontend server (local)"
    echo -e "  ${GREEN}./rh frontend test${NC}   - Run frontend tests"
    echo -e "  ${GREEN}./rh chatbot start${NC}   - Start the chatbot server (local)"
    echo -e "  ${GREEN}./rh docs start${NC}      - Start the documentation server (local)"
    echo -e "  ${GREEN}./rh worker start${NC}    - Start the Celery worker (local)"
    echo -e "  ${GREEN}./rh polyphemus start${NC} - Start the Polyphemus service (local)"
    echo -e "  ${GREEN}./rh help${NC}            - Show this help message"
    echo ""
    echo -e "${YELLOW}Examples:${NC}"
    echo -e "  ${BLUE}./rh start${NC}               # Start all services with Docker"
    echo -e "  ${BLUE}./rh dev${NC}                 # Setup dev environment (different ports)"
    echo -e "  ${BLUE}./rh stop${NC}                # Stop all Docker services"
    echo -e "  ${BLUE}./rh delete${NC}              # Delete everything (services, images, volumes, data)"
    echo -e "  ${BLUE}./rh logs backend${NC}        # View backend logs"
    echo -e "  ${BLUE}./rh backend start${NC}       # Start backend locally (without Docker)"
    echo -e "  ${BLUE}./rh frontend start${NC}      # Start frontend locally (without Docker)"
    echo -e "  ${BLUE}./rh frontend test${NC}       # Run frontend tests"
    echo -e "  ${BLUE}./rh chatbot start${NC}       # Start chatbot locally (without Docker)"
    echo -e "  ${BLUE}./rh polyphemus start${NC}    # Start Polyphemus locally (without Docker)"
    echo ""
}

# ============================================================================
# Common utility functions
# ============================================================================

# Function to check if Docker is running
check_docker() {
    if ! docker info > /dev/null 2>&1; then
        echo -e "${RED}‚ùå Error: Docker is not running${NC}"
        echo -e "${YELLOW}üí° Please start Docker Desktop and try again${NC}"
        exit 1
    fi
}

# Function to generate encryption key using Docker
generate_encryption_key() {
    docker run --rm python:3.10.17-slim sh -c \
        "pip install --quiet --no-cache-dir cryptography > /dev/null 2>&1 && \
         python3 -c 'from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())'" 2>/dev/null
}

# ============================================================================
# Dev environment functions
# ============================================================================

# Dev environment configuration (distinct from prod:5432/6379 and test:10000/10002)
DEV_POSTGRES_PORT=11000
DEV_REDIS_PORT=11001
DEV_ENV_MARKER="# Generated by ./rh dev script - DO NOT EDIT MANUALLY"

# Function to check if env file was generated by dev script
is_dev_generated() {
    local file="$1"
    [ -f "$file" ] && head -n1 "$file" | grep -qF "$DEV_ENV_MARKER"
}

# Function to prompt for overwrite
prompt_overwrite() {
    local file="$1"
    echo -e "${YELLOW}‚ö†Ô∏è  File exists: $file${NC}"
    echo -e "${YELLOW}   This file was NOT generated by ./rh dev script.${NC}"
    read -p "$(echo -e ${YELLOW}Overwrite? [y/N]: ${NC})" -r
    [[ $REPLY =~ ^[Yy]$ ]]
}

# Function to create/update backend .env file
create_backend_env() {
    local env_file="$SCRIPT_DIR/apps/backend/.env"
    local encryption_key="$1"

    # Check if file exists and wasn't generated by us
    if [ -f "$env_file" ] && ! is_dev_generated "$env_file"; then
        if ! prompt_overwrite "$env_file"; then
            echo -e "${BLUE}‚ÑπÔ∏è  Skipping $env_file${NC}"
            return 0
        fi
    fi

    echo -e "${GREEN}üìù Creating $env_file${NC}"
    cat > "$env_file" << EOF
$DEV_ENV_MARKER

QUICK_START=true

# Database (dev ports)
SQLALCHEMY_DATABASE_URL=postgresql://rhesis-user:rhesis-password@localhost:${DEV_POSTGRES_PORT}/rhesis-db
SQLALCHEMY_DB_DRIVER=postgresql
SQLALCHEMY_DB_PORT=${DEV_POSTGRES_PORT}
SQLALCHEMY_DB_USER=rhesis-user
SQLALCHEMY_DB_PASS=rhesis-password
SQLALCHEMY_DB_HOST=localhost:${DEV_POSTGRES_PORT}
SQLALCHEMY_DB_NAME=rhesis-db
DB_ENCRYPTION_KEY=${encryption_key}

# Redis (dev ports)
REDIS_URL=redis://:rhesis-redis-pass@localhost:${DEV_REDIS_PORT}/0
BROKER_URL=redis://:rhesis-redis-pass@localhost:${DEV_REDIS_PORT}/0
CELERY_RESULT_BACKEND=redis://:rhesis-redis-pass@localhost:${DEV_REDIS_PORT}/1

# Environment
ENVIRONMENT=local
BACKEND_ENV=local
LOG_LEVEL=DEBUG

# URLs
FRONTEND_URL=http://localhost:3000
BACKEND_URL=http://localhost:8080

# JWT
JWT_SECRET_KEY=dev-jwt-secret-key-change-in-production
JWT_ALGORITHM=HS256
JWT_ACCESS_TOKEN_EXPIRE_MINUTES=10080
EOF
}

# Function to create/update frontend .env.local file
create_frontend_env() {
    local env_file="$SCRIPT_DIR/apps/frontend/.env.local"

    # Check if file exists and wasn't generated by us
    if [ -f "$env_file" ] && ! is_dev_generated "$env_file"; then
        if ! prompt_overwrite "$env_file"; then
            echo -e "${BLUE}‚ÑπÔ∏è  Skipping $env_file${NC}"
            return 0
        fi
    fi

    echo -e "${GREEN}üìù Creating $env_file${NC}"
    cat > "$env_file" << EOF
$DEV_ENV_MARKER

NEXT_PUBLIC_QUICK_START=true
NEXT_PUBLIC_API_BASE_URL=http://localhost:8080
NEXT_PUBLIC_APP_URL=http://localhost:3000
BACKEND_URL=http://localhost:8080
NEXTAUTH_URL=http://localhost:3000
NEXTAUTH_SECRET=dev-nextauth-secret-change-in-production
NEXT_TELEMETRY_DISABLED=1
EOF
}

# Function to start dev environment
dev_start() {
    echo -e "${GREEN}üõ†Ô∏è  Setting up Rhesis Development Environment...${NC}"
    echo ""

    cd "$SCRIPT_DIR" || {
        echo -e "${RED}‚ùå Error: Script directory not found${NC}"
        exit 1
    }

    check_docker

    # Step 1: Generate encryption key
    echo -e "${YELLOW}üîë Generating encryption key...${NC}"
    ENCRYPTION_KEY=$(generate_encryption_key)
    if [ -z "$ENCRYPTION_KEY" ]; then
        echo -e "${RED}‚ùå Error: Failed to generate encryption key${NC}"
        exit 1
    fi
    echo -e "${GREEN}‚úÖ Encryption key generated${NC}"

    # Step 2: Create env files
    echo ""
    echo -e "${YELLOW}üìÅ Setting up environment files...${NC}"
    create_backend_env "$ENCRYPTION_KEY"
    create_frontend_env

    # Step 3: Start postgres and redis with dev ports
    echo ""
    echo -e "${YELLOW}üê≥ Starting dev containers (postgres:${DEV_POSTGRES_PORT}, redis:${DEV_REDIS_PORT})...${NC}"

    # Use a separate compose project name to avoid conflicts
    COMPOSE_PROJECT_NAME=rhesis-dev docker compose \
        -f docker-compose.yml \
        up -d postgres redis \
        -p ${DEV_POSTGRES_PORT}:5432 2>/dev/null || \
    docker run -d \
        --name rhesis-dev-postgres \
        -e POSTGRES_DB=rhesis-db \
        -e POSTGRES_USER=rhesis-user \
        -e POSTGRES_PASSWORD=rhesis-password \
        -p ${DEV_POSTGRES_PORT}:5432 \
        postgres:16-alpine 2>/dev/null || true

    docker run -d \
        --name rhesis-dev-redis \
        -p ${DEV_REDIS_PORT}:6379 \
        redis:7-alpine \
        redis-server --requirepass rhesis-redis-pass 2>/dev/null || true

    # Wait for postgres to be ready
    echo -e "${BLUE}‚è≥ Waiting for PostgreSQL to be ready...${NC}"
    for i in {1..30}; do
        if docker exec rhesis-dev-postgres pg_isready -U rhesis-user -d rhesis-db > /dev/null 2>&1; then
            echo -e "${GREEN}‚úÖ PostgreSQL is ready${NC}"
            break
        fi
        sleep 1
    done

    # Step 4: Run migrations
    echo ""
    echo -e "${YELLOW}üîÑ Running database migrations...${NC}"
    cd "$SCRIPT_DIR/apps/backend" || exit 1
    if [ -f "migrate.sh" ]; then
        ./migrate.sh && echo -e "${GREEN}‚úÖ Migrations completed${NC}" || \
            echo -e "${YELLOW}‚ö†Ô∏è  Migrations may have failed, check output above${NC}"
    fi
    cd "$SCRIPT_DIR"

    # Step 5: Display instructions
    echo ""
    echo -e "${PURPLE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${GREEN}‚úÖ Development environment ready!${NC}"
    echo -e "${PURPLE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo ""
    echo -e "${CYAN}üìã Running services:${NC}"
    echo -e "   PostgreSQL: ${WHITE}localhost:${DEV_POSTGRES_PORT}${NC}"
    echo -e "   Redis:      ${WHITE}localhost:${DEV_REDIS_PORT}${NC}"
    echo ""
    echo -e "${CYAN}üöÄ To start the backend:${NC}"
    echo -e "   ${GREEN}cd apps/backend && ./start.sh${NC}"
    echo ""
    echo -e "${CYAN}üåê To start the frontend:${NC}"
    echo -e "   ${GREEN}cd apps/frontend && npm install && npm run dev${NC}"
    echo ""
    echo -e "${CYAN}‚öôÔ∏è  To start the worker (optional):${NC}"
    echo -e "   ${GREEN}./rh worker start${NC}"
    echo ""
    echo -e "${YELLOW}üí° To stop dev containers:${NC}"
    echo -e "   ${GREEN}docker stop rhesis-dev-postgres rhesis-dev-redis${NC}"
    echo -e "   ${GREEN}docker rm rhesis-dev-postgres rhesis-dev-redis${NC}"
    echo ""
}

# Function to start all services with Docker Compose
start_all() {
    echo -e "${GREEN}üöÄ Starting all Rhesis services with Docker...${NC}"
    echo -e "${BLUE}‚ÑπÔ∏è  Using zero-configuration local setup${NC}"
    echo ""
    echo "#####################################################################################"
    echo ""
    echo -e "${CYAN}üìä Telemetry Notice:${NC}"
    echo -e "${WHITE}   Rhesis AI automatically collects anonymous usage statistics to help improve the platform.${NC}"
    echo -e "${WHITE}   To disable telemetry, set: ${YELLOW}OTEL_RHESIS_TELEMETRY_ENABLED=false${NC}"
    echo ""
    echo "#####################################################################################"
    echo ""

    cd "$SCRIPT_DIR" || {
        echo -e "${RED}‚ùå Error: Script directory not found${NC}"
        exit 1
    }

    check_docker

    # Check if .env.docker.local exists and has DB_ENCRYPTION_KEY
    if [ ! -f ".env.docker.local" ] || ! grep -q "^DB_ENCRYPTION_KEY=.\+" .env.docker.local 2>/dev/null; then
        echo -e "${YELLOW}üîë Generating DB_ENCRYPTION_KEY...${NC}"

        ENCRYPTION_KEY=$(generate_encryption_key)

        if [ -z "$ENCRYPTION_KEY" ]; then
            echo -e "${RED}‚ùå Error: Failed to generate encryption key${NC}"
            exit 1
        fi

        # Create or update .env.docker.local
        if [ ! -f ".env.docker.local" ]; then
            # Create new file
            echo "# Auto-generated local environment configuration" > .env.docker.local
            echo "" >> .env.docker.local
            echo "# Database Encryption" >> .env.docker.local
            echo "DB_ENCRYPTION_KEY=$ENCRYPTION_KEY" >> .env.docker.local
            echo "" >> .env.docker.local
            echo "# Local Authentication Bypass" >> .env.docker.local
            echo "QUICK_START=true" >> .env.docker.local
            echo "NEXT_PUBLIC_QUICK_START=true" >> .env.docker.local
            echo -e "${GREEN}‚úÖ Created .env.docker.local with local configuration${NC}"
        else
            # Update existing file
            if grep -q "^DB_ENCRYPTION_KEY=" .env.docker.local 2>/dev/null; then
                # Replace existing line
                if [[ "$OSTYPE" == "darwin"* ]]; then
                    sed -i '' "s|^DB_ENCRYPTION_KEY=.*|DB_ENCRYPTION_KEY=$ENCRYPTION_KEY|" .env.docker.local
                else
                    sed -i "s|^DB_ENCRYPTION_KEY=.*|DB_ENCRYPTION_KEY=$ENCRYPTION_KEY|" .env.docker.local
                fi
            else
                # Add new line
                echo "" >> .env.docker.local
                echo "DB_ENCRYPTION_KEY=$ENCRYPTION_KEY" >> .env.docker.local
            fi

            # Add QUICK_START if missing
            if ! grep -q "^QUICK_START=" .env.docker.local 2>/dev/null; then
                echo "QUICK_START=true" >> .env.docker.local
            fi

            # Add NEXT_PUBLIC_QUICK_START if missing
            if ! grep -q "^NEXT_PUBLIC_QUICK_START=" .env.docker.local 2>/dev/null; then
                echo "NEXT_PUBLIC_QUICK_START=true" >> .env.docker.local
            fi

            echo -e "${GREEN}‚úÖ Local configuration updated in .env.docker.local${NC}"
        fi
    fi

    echo ""
    echo -e "${YELLOW}üì¶ Starting services ...${NC}"
    
docker compose --env-file .env.docker.local up --build -d postgres redis backend worker frontend
    if [ $? -eq 0 ]; then
        echo ""
        echo -e "${GREEN}‚úÖ All services started successfully!${NC}"
        echo ""
        echo -e "${CYAN}üåê Access the platform:${NC}"
        echo -e "   Frontend:  ${WHITE}http://localhost:3000${NC} (auto-login enabled)"
        echo -e "   Backend:   ${WHITE}http://localhost:8080/docs${NC}"
        echo -e "   Worker:    ${WHITE}http://localhost:8081/health/basic${NC}"
        echo ""
        echo -e "${YELLOW}üí° Useful commands:${NC}"
        echo -e "   View logs:    ${GREEN}./rh logs${NC}"
        echo -e "   Stop all:     ${GREEN}./rh stop${NC}"
        echo -e "   Restart all:  ${GREEN}./rh restart${NC}"
        echo ""
    else
        echo -e "${RED}‚ùå Error: Failed to start services${NC}"
        exit 1
    fi
}

# Function to stop all services
stop_all() {
    echo -e "${YELLOW}üõë Stopping all Rhesis services...${NC}"

    cd "$SCRIPT_DIR" || {
        echo -e "${RED}‚ùå Error: Script directory not found${NC}"
        exit 1
    }

    docker compose down

    if [ $? -eq 0 ]; then
        echo -e "${GREEN}‚úÖ All services stopped${NC}"
    else
        echo -e "${RED}‚ùå Error: Failed to stop services${NC}"
        exit 1
    fi
}

# Function to restart all services
restart_all() {
    echo -e "${YELLOW}üîÑ Restarting all Rhesis services...${NC}"

    cd "$SCRIPT_DIR" || {
        echo -e "${RED}‚ùå Error: Script directory not found${NC}"
        exit 1
    }

    docker compose --env-file .env.docker.local restart

    if [ $? -eq 0 ]; then
        echo -e "${GREEN}‚úÖ All services restarted${NC}"
    else
        echo -e "${RED}‚ùå Error: Failed to restart services${NC}"
        exit 1
    fi
}

# Function to view logs
view_logs() {
    echo -e "${BLUE}üìã Viewing logs...${NC}"

    cd "$SCRIPT_DIR" || {
        echo -e "${RED}‚ùå Error: Script directory not found${NC}"
        exit 1
    }

    if [ -z "$1" ]; then
        # No service specified, show all logs
        docker compose logs -f
    else
        # Show logs for specific service
        docker compose logs -f "$1"
    fi
}

# Function to delete all services, images, volumes, and data
delete_all() {
    echo -e "${RED}‚ö†Ô∏è  WARNING: This will delete ALL Docker resources for Rhesis!${NC}"
    echo -e "${YELLOW}This includes:${NC}"
    echo -e "  - All running containers"
    echo -e "  - All Docker images"
    echo -e "  - All volumes (DATABASE DATA WILL BE LOST!)"
    echo -e "  - All networks"
    echo -e "  - .env.docker.local"
    echo ""
    echo -e "${RED}This action CANNOT be undone!${NC}"
    echo ""
    read -p "$(echo -e ${YELLOW}Are you sure you want to continue? Type \'yes\' to confirm: ${NC})" -r
    echo ""

    if [[ ! $REPLY =~ ^[Yy][Ee][Ss]$ ]]; then
        echo -e "${GREEN}‚úÖ Deletion cancelled${NC}"
        exit 0
    fi

    echo -e "${YELLOW}üóëÔ∏è  Deleting all Rhesis Docker resources...${NC}"

    cd "$SCRIPT_DIR" || {
        echo -e "${RED}‚ùå Error: Script directory not found${NC}"
        exit 1
    }

    # Stop and remove all services, volumes, and images
    docker compose down -v --rmi all

    rm -f .env.docker.local

    if [ $? -eq 0 ]; then
        echo ""
        echo -e "${GREEN}‚úÖ All Rhesis Docker resources deleted successfully!${NC}"
        echo ""
        echo -e "${CYAN}üí° To start fresh:${NC}"
        echo -e "   ${GREEN}./rh start${NC}"
        echo ""
    else
        echo -e "${RED}‚ùå Error: Failed to delete all resources${NC}"
        exit 1
    fi
}

# Function to start backend
start_backend() {
    echo -e "${GREEN}üîß Starting Rhesis Backend...${NC}"
    cd "$SCRIPT_DIR/apps/backend" || {
        echo -e "${RED}‚ùå Error: Backend directory not found${NC}"
        exit 1
    }

    if [ -f "start.sh" ]; then
        ./start.sh
    else
        echo -e "${RED}‚ùå Error: Backend start.sh not found${NC}"
        exit 1
    fi
}

# Function to start frontend
start_frontend() {
    echo -e "${GREEN}üåê Starting Rhesis Frontend...${NC}"
    cd "$SCRIPT_DIR/apps/frontend" || {
        echo -e "${RED}‚ùå Error: Frontend directory not found${NC}"
        exit 1
    }

    if [ -f "start.sh" ]; then
        ./start.sh
    else
        echo -e "${RED}‚ùå Error: Frontend start.sh not found${NC}"
        exit 1
    fi
}

# Function to start chatbot
start_chatbot() {
    echo -e "${GREEN}ü§ñ Starting Rhesis Chatbot...${NC}"
    cd "$SCRIPT_DIR/apps/chatbot" || {
        echo -e "${RED}‚ùå Error: Chatbot directory not found${NC}"
        exit 1
    }

    echo -e "${GREEN}üöÄ Starting Chatbot service...${NC}"
    echo -e "${BLUE}üåê Service will be available at: http://localhost:8000${NC}"
    echo -e "${BLUE}üìö API docs will be available at: http://localhost:8000/docs${NC}"
    echo -e "${YELLOW}üí° Press Ctrl+C to stop the service${NC}"
    echo ""

    # Run uvicorn with reload for development
    exec uv run uvicorn client:app --host 0.0.0.0 --port 8000 --reload
}

# Function to start docs
start_docs() {
    echo -e "${GREEN}üìö Starting Rhesis Documentation...${NC}"
    cd "$SCRIPT_DIR/docs/src" || {
        echo -e "${RED}‚ùå Error: Documentation directory not found${NC}"
        exit 1
    }

    if [ -f "start.sh" ]; then
        ./start.sh
    else
        echo -e "${RED}‚ùå Error: Docs start.sh not found${NC}"
        exit 1
    fi
}

# Function to start polyphemus
start_polyphemus() {
    echo -e "${GREEN}üîÆ Starting Rhesis Polyphemus...${NC}"
    cd "$SCRIPT_DIR" || {
        echo -e "${RED}‚ùå Error: Script directory not found${NC}"
        exit 1
    }

    # Check if virtual environment exists
    if [ ! -d ".venv" ]; then
        echo -e "${YELLOW}üì¶ Creating virtual environment...${NC}"
        uv venv || {
            echo -e "${RED}‚ùå Error: Failed to create virtual environment${NC}"
            exit 1
        }
    fi

    # Activate virtual environment
    source .venv/bin/activate || {
        echo -e "${RED}‚ùå Error: Failed to activate virtual environment${NC}"
        exit 1
    }

    # Install SDK first with huggingface extras (required by polyphemus)
    echo -e "${YELLOW}üì¶ Installing SDK with HuggingFace support...${NC}"
    uv pip install -e "sdk[huggingface]" || {
        echo -e "${RED}‚ùå Error: Failed to install SDK${NC}"
        exit 1
    }

    # Install Penelope
    echo -e "${YELLOW}üì¶ Installing Penelope...${NC}"
    uv pip install -e penelope || {
        echo -e "${RED}‚ùå Error: Failed to install Penelope${NC}"
        exit 1
    }

    # Install Backend
    echo -e "${YELLOW}üì¶ Installing Backend...${NC}"
    uv pip install -e apps/backend || {
        echo -e "${RED}‚ùå Error: Failed to install Backend${NC}"
        exit 1
    }

    # Install Polyphemus (all dependencies now resolved)
    echo -e "${YELLOW}üì¶ Installing Polyphemus...${NC}"
    uv pip install -e apps/polyphemus || {
        echo -e "${RED}‚ùå Error: Failed to install Polyphemus${NC}"
        exit 1
    }

    echo -e "${GREEN}üöÄ Starting Polyphemus service...${NC}"
    echo -e "${BLUE}üåê Service will be available at: http://localhost:8082${NC}"
    echo -e "${BLUE}üìö API docs will be available at: http://localhost:8082/docs${NC}"
    echo -e "${YELLOW}üí° Press Ctrl+C to stop the service${NC}"
    echo ""

    # Run uvicorn
    exec uvicorn rhesis.polyphemus.main:app --host 0.0.0.0 --port 8082 --reload
}

# Function to start worker
start_worker() {
    echo -e "${GREEN}‚öôÔ∏è  Starting Rhesis Worker...${NC}"

    # Kill any existing celery workers first
    echo -e "${YELLOW}üîç Checking for existing Celery workers...${NC}"
    if pgrep -f celery > /dev/null; then
        echo -e "${YELLOW}üõë Stopping existing Celery workers...${NC}"
        pkill -9 -f celery
        sleep 1
        echo -e "${GREEN}‚úÖ Existing workers stopped${NC}"
    else
        echo -e "${BLUE}‚ÑπÔ∏è  No existing workers found${NC}"
    fi

    # Clear Python cache
    echo -e "${YELLOW}üßπ Clearing Python cache...${NC}"
    cd "$SCRIPT_DIR" || {
        echo -e "${RED}‚ùå Error: Script directory not found${NC}"
        exit 1
    }
    find apps/backend -type d -name __pycache__ -exec rm -rf {} + 2>/dev/null
    find apps/backend -type f -name "*.pyc" -delete 2>/dev/null
    echo -e "${GREEN}‚úÖ Cache cleared${NC}"

    cd "$SCRIPT_DIR/apps/backend" || {
        echo -e "${RED}‚ùå Error: Backend directory not found${NC}"
        exit 1
    }

    LOG_FILE="$SCRIPT_DIR/celery.log"
    echo -e "${GREEN}üöÄ Starting new Celery worker...${NC}"
    echo -e "${BLUE}üìù Logs will be written to: ${LOG_FILE}${NC}"
    echo -e "${YELLOW}üí° Press Ctrl+C to stop the worker${NC}"
    echo ""

    # Set up trap to handle Ctrl+C gracefully
    trap "echo -e '\n${YELLOW}üõë Shutting down worker...${NC}'; exit" INT TERM

    # Set CELERY_WORKER_NAME environment variable (using hostname-UUID for uniqueness)
    # Generate unique worker ID using hostname + UUID
    # Format: worker@hostname-uuid (e.g., worker@server1-a1b2c3d4)
    # UUID ensures no collisions even with rapid worker restarts
    WORKER_UUID=$(python3 -c "import uuid; print(str(uuid.uuid4())[:8])")
    export CELERY_WORKER_NAME="worker@$(hostname)-${WORKER_UUID}"
    echo -e "${GREEN}‚úÖ CELERY_WORKER_NAME set to: ${CELERY_WORKER_NAME}${NC}"

    # Run in foreground - using uv run handles the virtual environment automatically
    # Using --logfile parameter to write logs directly
    # Using --pool=solo to avoid forking issues on macOS with ML libraries (DeepEval/PyTorch)
    # Using -E to enable events for worker discovery
    # Configuration matches apps/worker/start.sh for consistency
    exec uv run celery -A rhesis.backend.worker.app worker \
        --loglevel=DEBUG \
        --queues=celery,execution,telemetry \
        --pool=solo \
        --prefetch-multiplier=1 \
        --max-tasks-per-child=500 \
        --optimization=fair \
        -E \
        --logfile="$LOG_FILE"
}

# Function to run frontend tests
test_frontend() {
    echo -e "${GREEN}üß™ Running Frontend Tests...${NC}"
    cd "$SCRIPT_DIR/apps/frontend" || {
        echo -e "${RED}‚ùå Error: Frontend directory not found${NC}"
        exit 1
    }

    # Check if node_modules exists
    if [ ! -d "node_modules" ]; then
        echo -e "${YELLOW}üì¶ Installing dependencies first...${NC}"
        npm install || {
            echo -e "${RED}‚ùå Error: Failed to install dependencies${NC}"
            exit 1
        }
    fi

    # Run tests
    echo -e "${BLUE}üß™ Executing tests...${NC}"
    npm test || {
        echo -e "${RED}‚ùå Error: Tests failed${NC}"
        exit 1
    }

    echo -e "${GREEN}‚úÖ Frontend tests completed!${NC}"
}

# Parse command line arguments
case "$1" in
    "start")
        start_all
        ;;
    "dev")
        dev_start
        ;;
    "stop")
        stop_all
        ;;
    "restart")
        restart_all
        ;;
    "logs")
        view_logs "$2"
        ;;
    "delete")
        delete_all
        ;;
    "backend")
        case "$2" in
            "start")
                start_backend
                ;;
            *)
                echo -e "${RED}‚ùå Unknown backend command: $2${NC}"
                echo -e "${YELLOW}Use: ./rh backend start${NC}"
                exit 1
                ;;
        esac
        ;;
    "frontend")
        case "$2" in
            "start")
                start_frontend
                ;;
            "test")
                test_frontend
                ;;
            *)
                echo -e "${RED}‚ùå Unknown frontend command: $2${NC}"
                echo -e "${YELLOW}Use: ./rh frontend start or ./rh frontend test${NC}"
                exit 1
                ;;
        esac
        ;;
    "chatbot")
        case "$2" in
            "start")
                start_chatbot
                ;;
            *)
                echo -e "${RED}‚ùå Unknown chatbot command: $2${NC}"
                echo -e "${YELLOW}Use: ./rh chatbot start${NC}"
                exit 1
                ;;
        esac
        ;;
    "docs")
        case "$2" in
            "start")
                start_docs
                ;;
            *)
                echo -e "${RED}‚ùå Unknown docs command: $2${NC}"
                echo -e "${YELLOW}Use: ./rh docs start${NC}"
                exit 1
                ;;
        esac
        ;;
    "worker")
        case "$2" in
            "start")
                start_worker
                ;;
            *)
                echo -e "${RED}‚ùå Unknown worker command: $2${NC}"
                echo -e "${YELLOW}Use: ./rh worker start${NC}"
                exit 1
                ;;
        esac
        ;;
    "polyphemus")
        case "$2" in
            "start")
                start_polyphemus
                ;;
            *)
                echo -e "${RED}‚ùå Unknown polyphemus command: $2${NC}"
                echo -e "${YELLOW}Use: ./rh polyphemus start${NC}"
                exit 1
                ;;
        esac
        ;;
    "help"|"--help"|"-h"|"")
        show_help
        ;;
    *)
        echo -e "${RED}‚ùå Unknown command: $1${NC}"
        echo ""
        show_help
        exit 1
        ;;
esac
