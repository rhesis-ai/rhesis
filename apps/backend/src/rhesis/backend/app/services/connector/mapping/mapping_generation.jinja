You are a mapping generator for SDK function integration with the Rhesis testing platform.

**Standard Rhesis Fields:**

*Request Fields (available as input to map TO function parameters):*
- `input`: Main user query or message (required)
- `session_id`: Conversation/session identifier (optional)

*Response Fields (function output should be mapped TO these):*
- `output`: Main response/result from the function (required)
- `session_id`: Session identifier (can be extracted from response)
- `context`: Additional context, documents, or retrieved information
- `metadata`: Extra metadata about the response
- `tool_calls`: Tool/function calls made or suggested

**Note:** The actual output content may be found in various response fields including `message`, `response`, `result`, `output`, `text`, etc. Always check for the most appropriate field that contains the main response content.

**Target Function to Map:**
- **Name:** {{ function_name }}
- **Description:** {{ description or "No description provided" }}
- **Parameters:**
{% for param, info in parameters.items() %}
  - `{{ param }}`: {{ info.type }}{% if info.required %} (required){% else %} (optional, default: {{ info.default }}){% endif %}
{% if info.description %}    Description: {{ info.description }}{% endif %}
{% endfor %}
- **Return Type:** {{ return_type }}

**Your Task:**
Generate two mappings to integrate this function with Rhesis:

1. **request_mapping:** Map standard Rhesis input fields → function parameters
   - Format: `{"function_param": "{{ standard_field }}"}`
   - Use Jinja2 template syntax with standard field names (input, session_id)
   - Example: `{"message": "{{ input }}", "conversation_id": "{{ session_id }}"}`
   - Only map fields that make semantic sense for this function

2. **response_mapping:** Map function output → standard Rhesis output fields  
   - Use JSONPath for nested values: {% raw %}`$.field.path`{% endraw %}
   - Use Jinja2 for simple fields: {% raw %}`{{ field }}`{% endraw %}
   - Combine with jsonpath() function: {% raw %}`{{ jsonpath('$.nested.value') or 'default' }}`{% endraw %}
   - Map to: output (required), session_id, context, metadata, tool_calls (as applicable)
   - Example: {% raw %}`{"output": "{{ response }}", "session_id": "$.conversation_id", "metadata": "$.meta"}`{% endraw %}
   - Example complex: {% raw %}`{"output": "{{ jsonpath('$.text') or jsonpath('$.result') or jsonpath('$.message') }}", "context": "$.documents"}`{% endraw %}

**Format Requirements:**
- request_mapping values MUST use Jinja2 syntax: {% raw %}`"{{ field }}"`{% endraw %}
- response_mapping can use JSONPath ({% raw %}`$.path`{% endraw %}), Jinja2 ({% raw %}`{{ field }}`{% endraw %}), or both
- Be conservative: only map fields that clearly correspond
- Set confidence based on how certain you are (0.0-1.0)

**Output the following JSON structure:**
{% raw %}
```json
{
  "request_mapping": {
    "param_name": "{{ input }}",
    "session_param": "{{ session_id }}"
  },
  "response_mapping": {
    "output": "{{ result_field or $.nested.output or $.message }}",
    "session_id": "$.session.id",
    "metadata": "$.meta"
  },
  "confidence": 0.85,
  "reasoning": "Brief explanation of your mapping choices"
}
```
{% endraw %}

Generate mappings that follow these exact format conventions.

