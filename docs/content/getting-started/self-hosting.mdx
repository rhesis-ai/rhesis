import { CodeBlock } from '@/components/CodeBlock'
import { Table } from '@/components/Table'
import { FileTree } from '@/components/FileTree'

# Self-hosting

You can self-host Rhesis on your own infrastructure.

This guide covers two deployment scenarios:

1. **Zero-Configuration Local Deployment** - Get started immediately with pre-configured defaults
2. **Production Deployment** - Full configuration for production environments

> **Important**: This guide uses Docker Compose V2 syntax (`docker compose` without hyphen). If you're using an older version of Docker, you may need to install Docker Compose V2 or use the legacy `docker-compose` command.

---

## Zero-Configuration Local Deployment

Perfect for quickly testing Rhesis locally without any configuration hassles. This setup includes:

- ‚úÖ **No Auth0 setup required** - Local authentication bypass enabled
- ‚úÖ **Pre-configured database** - PostgreSQL with automatic setup
- ‚úÖ **Auto-login enabled** - Access the dashboard immediately
- ‚úÖ **Default admin user** - `admin@local.dev` created automatically
- ‚úÖ **All secrets included** - Development-safe defaults provided

<Callout type="warning">
**Local Deployment Only**

This configuration is **NOT suitable for production**. It includes hardcoded secrets and disabled security features for ease of local deployment.
</Callout>

### Prerequisites

- Docker Desktop installed and running
- Git (to clone the repository)
- Ports 3000, 8080, 8081, 5432, and 6379 available on your system

### Quick Start

Get Rhesis running in under 5 minutes:

<CodeBlock filename="Terminal" language="bash">
{`# 1. Clone the repository
git clone https://github.com/rhesis-ai/rhesis.git
cd rhesis

# 2. Start all services with one command
./rh start

# That's it! The platform will automatically:
# - Generate database encryption key
# - Create .env.docker.local with local configuration
# - Start all services (backend, frontend, database, worker)
# - Create default admin user and example data
# - Enable auto-login

# 3. Access the platform
# Frontend: http://localhost:3000 (auto-login enabled)
# Backend API: http://localhost:8080/docs
# Worker Health: http://localhost:8081/health/basic

# 4. (Optional) Enable test generation
# Get your API key from https://app.rhesis.ai/
# Edit .env.docker.local and update RHESIS_API_KEY=your-actual-key`}
</CodeBlock>

That's it! The `./rh start` command automatically:
- Checks if Docker is running
- Generates a secure database encryption key
- Creates `.env.docker.local` with all required configuration
- Enables local authentication bypass (auto-login)
- Starts all services
- Creates the database and runs migrations
- Creates the default admin user (`Local Admin`)
- Loads example test data

### Configuration Files

The zero-configuration setup uses these files:

<FileTree
  title="Local Deployment Files"
  data={[
    {
      name: '.env.docker.local',
      type: 'file',
      description: 'Auto-generated environment file (created by ./rh start)'
    },
    {
      name: 'docker-compose.yml',
      type: 'file',
      description: 'Docker Compose configuration with sensible defaults'
    },
    {
      name: 'rh',
      type: 'file',
      description: 'CLI tool for managing services (start, stop, logs, delete)'
    }
  ]}
/>

### What's Auto-Generated

When you run `./rh start`, the `.env.docker.local` file is automatically created with:

**Auto-Generated Keys:**
- Database encryption key (using Python cryptography.fernet)
- Local authentication bypass flags

**You can add (optional):**
- Rhesis API key (for test generation)
- AI provider keys (Gemini, OpenAI, Azure)
- SMTP credentials (for email notifications)

**Default Services:**
- Backend API on port 8080
- Frontend on port 3000 
- Worker on port 8081
- PostgreSQL on port 5432
- Redis on port 6379

### Default Access

Once running, access the platform at:

<Table
  headers={['Service', 'URL', 'Credentials']}
  rows={[
    ['Frontend', 'http://localhost:3000', 'Auto-login (no credentials needed)'],
    ['Backend API', 'http://localhost:8080/docs', 'API documentation'],
    ['Worker Health', 'http://localhost:8081/health/basic', 'Health check endpoint'],
    ['Default Admin', 'Local Admin', 'Created automatically with auto-login'],
  ]}
  align={['left', 'left', 'left']}
/>

### Optional: Configure AI Providers

The local setup works out-of-the-box, but to enable test generation, you need an AI provider. Two options:

**Option 1: Use Rhesis API (Recommended)**

1. Get your API key from https://app.rhesis.ai/
2. Edit `.env.docker.local` and add:

<CodeBlock filename=".env.docker.local" language="bash">
{`RHESIS_API_KEY=your-actual-rhesis-api-key-here`}
</CodeBlock>

**Option 2: Use Your Own AI Provider**

Add your provider's credentials to `.env.docker.local`:

<CodeBlock filename=".env.docker.local" language="bash">
{`# Google Gemini
GEMINI_API_KEY=your-gemini-api-key
GEMINI_MODEL_NAME=gemini-2.0-flash-001
GOOGLE_API_KEY=your-google-api-key

# Or Azure OpenAI
AZURE_OPENAI_ENDPOINT=your-endpoint
AZURE_OPENAI_API_KEY=your-key
AZURE_OPENAI_DEPLOYMENT_NAME=gpt-4o
AZURE_OPENAI_API_VERSION=your-version

# Or OpenAI
OPENAI_API_KEY=your-openai-key
OPENAI_MODEL_NAME=gpt-4o`}
</CodeBlock>

After updating, restart services:
<CodeBlock filename="Terminal" language="bash">
{`./rh restart`}
</CodeBlock>

### Managing Services

Use the `./rh` CLI for easy service management:

**Stop services:**

<CodeBlock filename="Terminal" language="bash">
{`# Stop all services
./rh stop`}
</CodeBlock>

**View logs:**

<CodeBlock filename="Terminal" language="bash">
{`# All services (follow in real-time)
./rh logs

# Specific service
./rh logs backend
./rh logs frontend
./rh logs worker`}
</CodeBlock>

**Restart services:**

<CodeBlock filename="Terminal" language="bash">
{`# Restart all services
./rh restart`}
</CodeBlock>

**Delete everything (fresh start):**

<CodeBlock filename="Terminal" language="bash">
{`# Remove all containers, volumes, images, and data
./rh delete

# Then start fresh
./rh start`}
</CodeBlock>

### Troubleshooting

**Docker not running:**

<CodeBlock filename="Terminal" language="bash">
{`# The ./rh start command checks automatically
# If you see this error:
# ‚ùå Error: Docker is not running
# üí° Please start Docker Desktop and try again

# Start Docker Desktop, then run:
./rh start`}
</CodeBlock>

**Port already in use:**

<CodeBlock filename="Terminal" language="bash">
{`# Check what's using a port (e.g., port 3000)
lsof -i :3000

# Kill the process
kill -9 <PID>`}
</CodeBlock>

**Need a fresh start:**

<CodeBlock filename="Terminal" language="bash">
{`# Delete everything and start fresh
./rh delete
./rh start`}
</CodeBlock>

**Check service health:**

<CodeBlock filename="Terminal" language="bash">
{`# View all running containers
docker compose ps

# Check backend health
curl http://localhost:8080/health

# Check worker health
curl http://localhost:8081/health/basic`}
</CodeBlock>

**Python cryptography package missing:**

<CodeBlock filename="Terminal" language="bash">
{`# If you see this error:
# ‚ùå Error: Failed to generate encryption key
# üí° Make sure Python 3 and cryptography package are installed

# Install the package:
pip install cryptography

# Then run:
./rh start`}
</CodeBlock>

---

## Production Deployment

For production environments, you need to configure authentication, security, and other production concerns properly.

<Callout type="info">
**Production Setup**

This section covers deploying Rhesis for production use with proper security configuration, custom authentication setup, and environment-specific settings.
</Callout>

### Prerequisites

- Docker Desktop installed and running
- Git (to clone the repository)
- Ports 3000, 8080, 8081, 5432, and 6379 available on your system

### System Requirements

#### Local Deployment Environment

For local deployment, testing, and evaluation:

<Table
  headers={["Resource", "Minimum", "Recommended"]}
  rows={[
    ["RAM", "4 GB", "6 GB"],
    ["Storage", "8 GB free", "15 GB free"],
    ["CPU", "2 cores", "4 cores"],
    ["Network", "Stable internet", "Broadband"],
  ]}
  align={["left", "center", "center"]}
/>

**Local Deployment Notes:**

- Includes hot-reload and development tools
- Lower concurrent user load
- Smaller dataset for testing
- Debug logging enabled

#### Production Environment

For production deployment with real users:

<Table
  headers={["Resource", "Minimum", "Recommended", "High-Scale"]}
  rows={[
    ["RAM", "8 GB", "16 GB", "32 GB+"],
    ["Storage", "20 GB SSD", "50 GB SSD", "100 GB+ SSD"],
    ["CPU", "4 cores", "8 cores", "16+ cores"],
    ["Network", "50 Mbps", "100 Mbps", "1 Gbps+"],
  ]}
  align={["left", "center", "center", "center"]}
/>

**Production Notes:**

- Optimized builds without development overhead
- Higher concurrent user capacity
- Production logging levels
- Database connection pooling

#### Detailed Resource Breakdown

**Memory Usage by Environment:**

<Table
  headers={["Service", "Local Deployment", "Production"]}
  rows={[
    ["PostgreSQL", "~256 MB", "~1-2 GB"],
    ["Redis", "~50 MB", "~500 MB - 1 GB"],
    ["Backend", "~150 MB", "~500 MB - 1 GB"],
    ["Worker", "~200 MB", "~1-2 GB"],
    ["Frontend", "~100 MB", "~200-400 MB"],
    ["Docker Overhead", "~300 MB", "~500 MB - 1 GB"],
    ["**Total Estimated**", "**~1.1 GB**", "**~3.7-7.1 GB**"],
  ]}
  align={["left", "right", "right"]}
/>

**Storage Requirements:**

<Table
  headers={["Component", "Local Deployment", "Production"]}
  rows={[
    ["Application Code", "~2 GB", "~2 GB"],
    ["Database", "~500 MB", "~5-50 GB+"],
    ["Docker Images", "~3 GB", "~3-4 GB"],
    ["Logs & Cache", "~500 MB", "~2-10 GB"],
    ["Working Space", "~1 GB", "~3-5 GB"],
    ["**Total Estimated**", "**~7 GB**", "**~15-75 GB+**"],
  ]}
  align={["left", "right", "right"]}
/>

#### Performance Characteristics

**CPU Usage Patterns:**

- **High Load**: AI processing, bulk data operations, migrations
- **Normal Load**: API requests, background tasks, web serving
- **Idle**: Minimal CPU during low activity periods

**Scaling Factors:**

- **AI Operations**: Memory spikes during model inference
- **Concurrent Users**: ~50-100 MB RAM per active user
- **Database Growth**: Storage scales with user data and analytics
- **Background Tasks**: CPU-intensive during batch processing

#### Docker Compose Version Note

**Why `docker compose` instead of `docker-compose`?**

- **`docker-compose` (V1)**: The original standalone tool written in Python, **deprecated as of June 2023**
- **`docker compose` (V2)**: The modern version integrated into Docker CLI, written in Go with better performance

If you encounter errors with `docker-compose`, you're likely using the deprecated V1. Switch to `docker compose` (V2) for:

- Better performance and reliability
- Active maintenance and security updates
- Support for newer Docker features
- Improved integration with Docker CLI

### Quick Start

1. **Clone the repository**

<CodeBlock filename="Terminal" language="bash">
{`git clone <repository-url>
cd rhesis`}
</CodeBlock>

2. **Copy environment variables**

<CodeBlock filename="Terminal" language="bash">
{`cp .env.example .env.docker`}
</CodeBlock>

3. **Configure environment variables**

   Edit the `.env.docker` file and update the following configurations:
   - Auth0 configuration
   - JWT configuration
   - Azure OpenAI configuration
   - Gemini configuration
   - SMTP configuration
   - NextAuth.js configuration
   - Any other environment variables as needed

4. **Start all services**

<CodeBlock filename="Terminal" language="bash">
{`docker compose --env-file .env.docker up -d`}
</CodeBlock>

5. **Access the applications**
   - **Frontend**: http://localhost:3000
   - **Backend API**: http://localhost:8080/docs
   - **Worker Health**: http://localhost:8081/health/basic

### Architecture Overview

#### Services

The Rhesis platform consists of several interconnected services:

<Table
  headers={["Service", "Port", "Description", "Health Check"]}
  rows={[
    ["PostgreSQL", "5432", "Primary database", "`pg_isready`"],
    ["Redis", "6379", "Cache & message broker", "`redis-cli ping`"],
    ["Backend", "8080", "FastAPI application", "`curl /health`"],
    ["Worker", "8081", "Celery background tasks", "`curl /health/basic`"],
    ["Frontend", "3000", "Next.js application", "`curl /api/auth/session`"],
  ]}
  align={["left", "center", "left", "left"]}
/>

#### Service Dependencies

<CodeBlock filename="Architecture Diagram" isTerminal={true}>
{`Frontend ‚Üí Backend ‚Üí PostgreSQL
             ‚Üì
           Redis ‚Üê Worker`}
</CodeBlock>

### Automated Database Setup

**No manual database setup required!** The system automatically handles:

- PostgreSQL database and user creation
- Database ownership and permissions setup
- Automatic Alembic migration execution
- Table and relationship creation
- Migration status checking (prevents duplicate migrations)

The backend container startup process:

1. Waits for PostgreSQL to be ready
2. Sets proper database ownership
3. Runs all pending migrations
4. Starts the FastAPI application

### Environment Configuration

#### Required Environment Variables

Update your `.env.docker` file with the following configurations:

**Authentication & Security:**

These variables configure user authentication and security for the platform:

<CodeBlock filename=".env.docker" language="bash">
{`# Auth0 Configuration
# Used for user authentication and authorization
AUTH0_DOMAIN=your-auth0-domain
AUTH0_AUDIENCE=your-auth0-audience
AUTH0_CLIENT_ID=your-auth0-client-id
AUTH0_CLIENT_SECRET=your-auth0-client-secret
AUTH0_SECRET_KEY=your-auth0-secret-key

# JWT Configuration

# Used for secure token generation and validation

JWT_SECRET_KEY=your-jwt-secret-key
JWT_ALGORITHM=HS256
JWT_ACCESS_TOKEN_EXPIRE_MINUTES=10080

# NextAuth Configuration

# Required for Next.js authentication integration

NEXTAUTH_SECRET=your-nextauth-secret
NEXTAUTH_URL=http://localhost:3000

# Frontend Configuration

# Public variables accessible in the browser for Auth0 integration

NEXT_PUBLIC_AUTH0_DOMAIN=your-auth0-domain
NEXT_PUBLIC_AUTH0_CLIENT_ID=your-auth0-client-id`}

</CodeBlock>

**OAuth Providers (Optional):**

Additional authentication providers for user login options:

<CodeBlock filename=".env.docker" language="bash">
{`# Google OAuth (Optional)
# Enables Google sign-in for users
GOOGLE_CLIENT_ID=your-google-client-id
GOOGLE_CLIENT_SECRET=your-google-client-secret`}
</CodeBlock>

**Email Configuration (Optional):**

Required for sending system emails, notifications, and user communications:

<CodeBlock filename=".env.docker" language="bash">
{`# SMTP Configuration (Optional)
# Used for sending emails (notifications, invitations, etc.)
SMTP_HOST=your_smtp_host
SMTP_PORT=465
SMTP_USER=your_smtp_user
SMTP_PASSWORD=your_smtp_password
FROM_EMAIL=your_from_email`}
</CodeBlock>

**AI Model Configuration (Optional):**

Configure AI providers for natural language processing and content generation:

<CodeBlock filename=".env.docker" language="bash">
{`# Gemini AI Configuration (Optional)
# Google's Gemini AI for advanced language processing
GEMINI_API_KEY=your-gemini-api-key
GOOGLE_API_KEY=your-google-api-key
GEMINI_MODEL_NAME=gemini-2.0-flash-001

# Azure OpenAI Configuration (Optional)

# Microsoft Azure's OpenAI service for GPT models

AZURE_OPENAI_ENDPOINT=YOUR_AZURE_OPENAI_API_ENDPOINT
AZURE_OPENAI_API_KEY=YOUR_AZURE_OPENAI_API_KEY
AZURE_OPENAI_DEPLOYMENT_NAME=gpt-4o
AZURE_OPENAI_API_VERSION=YOUR_AZURE_OPENAI_API_VERSION

# OpenAI Configuration (Optional)

# Direct OpenAI API integration for GPT models

OPENAI_API_KEY=YOUR_OPENAI_API_KEY
OPENAI_MODEL_NAME=gpt-4o`}

</CodeBlock>

> **Note**: At least one AI provider configuration is recommended for full platform functionality. You can choose between Gemini, Azure OpenAI, or OpenAI based on your preferences and requirements.

#### Telemetry Configuration (Optional)
Configure OpenTelemetry for monitoring and observability of your Rhesis deployment:

<CodeBlock filename=".env.docker" language="bash">
{`# OpenTelemetry Configuration (Optional)
# Used for collecting telemetry data (traces, metrics) for monitoring

# OTel Collector endpoint (where telemetry data is sent)
OTEL_EXPORTER_OTLP_ENDPOINT=https://rhesis-otel-collector-dev-235yqdecwq-uc.a.run.app/

# Service name for telemetry identification
OTEL_SERVICE_NAME=rhesis

# Deployment type: "self-hosted" or "cloud"
OTEL_DEPLOYMENT_TYPE=self-hosted

# Enable/disable telemetry collection
# self-hosted: opt-in (set to true to enable)
# Cloud: typically enabled by default
OTEL_RHESIS_TELEMETRY_ENABLED=true`}
</CodeBlock>

## Management Commands

#### Service Management

**Start services:**

<CodeBlock filename="Terminal" language="bash">
{`# Start all services in detached mode
docker compose --env-file .env.docker up -d

# Start with logs visible

docker compose --env-file .env.docker up`}

</CodeBlock>

**Stop services:**

<CodeBlock filename="Terminal" language="bash">
{`# Stop all services
docker compose down

# Stop and remove volumes (WARNING: deletes all data)

docker compose down -v`}

</CodeBlock>

**Restart services:**

<CodeBlock filename="Terminal" language="bash">
{`# Restart all services
docker compose --env-file .env.docker restart

# Restart specific service

docker compose --env-file .env.docker restart backend`}

</CodeBlock>

#### Monitoring and Logs

**View logs:**

<CodeBlock filename="Terminal" language="bash">
{`# All services
docker compose logs

# Specific service

docker compose logs backend
docker compose logs frontend
docker compose logs worker

# Follow logs in real-time

docker compose logs -f backend`}

</CodeBlock>

**Check service status:**

<CodeBlock filename="Terminal" language="bash">
{`# View running containers and their status
docker compose ps`}
</CodeBlock>

#### Building and Updates

**Rebuild services:**

<CodeBlock filename="Terminal" language="bash">
{`# Rebuild all services
docker compose --env-file .env.docker build

# Rebuild specific service

docker compose --env-file .env.docker build backend

# Rebuild and restart

docker compose --env-file .env.docker up -d --build`}

</CodeBlock>

#### Database Operations

The database is automatically managed, but you can access it directly if needed:

<CodeBlock filename="Terminal" language="bash">
{`# Connect to PostgreSQL
docker exec -it rhesis-postgres psql -U rhesis-user -d rhesis-db

# Check current migration status

docker exec rhesis-backend bash -c "cd src/rhesis/backend && alembic current"

# Run migrations manually (if needed)

docker exec rhesis-backend bash -c "cd src/rhesis/backend && alembic upgrade head"

# View migration history

docker exec rhesis-backend bash -c "cd src/rhesis/backend && alembic history"`}

</CodeBlock>

### Troubleshooting

#### Common Issues

**Database Migration Problems:**

1. Check migration status:

<CodeBlock filename="Terminal" language="bash">
{`docker exec rhesis-backend bash -c "cd src/rhesis/backend && alembic current"`}
</CodeBlock>

2. View migration logs:

<CodeBlock filename="Terminal" language="bash">
{`docker compose logs backend | grep -i migration`}
</CodeBlock>

3. Reset database (WARNING: deletes all data):

<CodeBlock filename="Terminal" language="bash">
{`docker compose down -v
docker compose --env-file .env.docker up -d`}
</CodeBlock>

**Service Health Issues:**

1. Check service status:

<CodeBlock filename="Terminal" language="bash">
{`docker compose ps`}
</CodeBlock>

2. Verify environment variables:

<CodeBlock filename="Terminal" language="bash">
{`docker exec rhesis-backend env | grep AUTH0`}
</CodeBlock>

3. Check resource usage:

<CodeBlock filename="Terminal" language="bash">
{`docker stats`}
</CodeBlock>

**Port Conflicts:**

If you encounter port conflicts, you can modify the ports in `docker compose.yml` or stop conflicting services:

<CodeBlock filename="Terminal" language="bash">
{`# Check what's using a port (e.g., port 3000)
lsof -i :3000

# Kill process using the port

kill -9 <PID>`}

</CodeBlock>

#### Performance Optimization

**Resource Allocation:**

- Ensure Docker has at least 4GB RAM allocated
- Monitor disk space usage with `docker system df`
- Clean up unused resources with `docker system prune`

**Database Performance:**

- Monitor PostgreSQL logs: `docker compose logs postgres`
- Check connection counts and slow queries

#### Security Considerations

- Change default passwords in production
- Use strong JWT secrets
- Configure proper firewall rules
- Keep environment variables secure
- Regularly update Docker images

### Backup and Recovery

#### Database Backup

<CodeBlock filename="Terminal" language="bash">
{`# Create database backup
docker exec rhesis-postgres pg_dump -U rhesis-user rhesis-db > backup.sql

# Restore from backup

docker exec -i rhesis-postgres psql -U rhesis-user -d rhesis-db < backup.sql`}

</CodeBlock>

#### Full System Backup

<CodeBlock filename="Terminal" language="bash">
{`# Stop services
docker compose down

# Backup volumes

docker run --rm -v rhesis_postgres_data:/data -v $(pwd):/backup alpine tar czf /backup/postgres_backup.tar.gz -C /data .
docker run --rm -v rhesis_redis_data:/data -v $(pwd):/backup alpine tar czf /backup/redis_backup.tar.gz -C /data .

# Restart services

docker compose --env-file .env.docker up -d`}

</CodeBlock>

### Support and Resources

#### Getting Help

If you encounter issues:

1. Check the logs: `docker compose logs`
2. Verify environment variables are set correctly
3. Ensure Docker has sufficient resources
4. Check if ports are available and not in use
5. Review the [main documentation](https://docs.rhesis.ai) for additional guidance

#### Additional Resources

- [Backend Documentation](https://docs.rhesis.ai/development/backend)
- [Frontend Documentation](https://docs.rhesis.ai/development/frontend)
- [Worker Documentation](https://docs.rhesis.ai/development/worker)
- [Environment Setup Guide](https://docs.rhesis.ai/development/environment-setup)

---

For local development setup without Docker (for contributing to Rhesis), see the üîß [Environment Setup Guide](https://docs.rhesis.ai/development/environment-setup).
