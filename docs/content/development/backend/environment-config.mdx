import { CodeBlock } from '@/components/CodeBlock'

# Environment Configuration

## Overview

The Rhesis backend uses environment variables for configuration, allowing for different settings across development, testing, and production environments. This approach follows the [12-factor app](https://12factor.net/) methodology for configuration management.

## Environment Variables Reference

For a complete list of all environment variables, their requirements, and descriptions, see the [Environment Variables](../environment-variables.mdx).

## Environment Files

The application supports multiple environment files:

- `.env`: Default environment file for local development
- `.env.docker`: Environment configuration for Docker deployment
- `.env.test`: Environment configuration for testing (not committed to version control)

## Loading Environment Variables

Environment variables are loaded using the `python-dotenv` library:

<CodeBlock filename="python" language="python">
{`from dotenv import load_dotenv

load_dotenv()  # Loads variables from .env file`}
</CodeBlock>

## Environment-Specific Configuration

The application can load different configuration based on the environment:

<CodeBlock filename="python" language="python">
{`import os

# Determine environment
ENV = os.getenv("ENV", "development")

# Load environment-specific settings
if ENV == "production":
    # Production settings
    DEBUG = False
    LOG_LEVEL = "INFO"
elif ENV == "testing":
    # Testing settings
    DEBUG = True
    LOG_LEVEL = "DEBUG"
    # Use in-memory database
    SQLALCHEMY_DATABASE_URL = "sqlite:///:memory:"
else:
    # Development settings
    DEBUG = True
    LOG_LEVEL = "DEBUG"`}
</CodeBlock>

## Configuration Validation

The application validates critical configuration at startup:

<CodeBlock filename="python" language="python">
{`def validate_config():
    """Validate that all required configuration is present."""
    required_vars = [
        "SQLALCHEMY_DATABASE_URL",
        "JWT_SECRET_KEY",
        "AUTH0_DOMAIN",
        "AUTH0_CLIENT_ID",
    ]

    missing = [var for var in required_vars if not os.getenv(var)]

    if missing:
        raise ValueError(f"Missing required environment variables: {', '.join(missing)}")`}
</CodeBlock>

## Docker Environment

When running in Docker, environment variables can be passed in several ways:

1. Through the `environment` section in `docker-compose.yml`
2. Using the `--env-file` flag with `docker run`
3. Setting individual variables with `-e` flags

Example Docker Compose configuration:

<CodeBlock filename="docker-compose.yml" language="yaml">
{`services:
  backend:
    build: ./apps/backend
    env_file:
      - ./apps/backend/.env.docker
    environment:
      - SQLALCHEMY_DB_HOST=postgres
      - LOG_LEVEL=INFO`}
</CodeBlock>

## Cloud Deployment

For cloud deployments, environment variables should be set using the cloud provider's secrets or environment configuration:

- Google Cloud: Secret Manager and environment variables in Cloud Run
- AWS: Parameter Store/Secrets Manager and environment variables in ECS/Lambda
- Azure: Key Vault and App Configuration

## Security Best Practices

- ⚠️ **Never commit sensitive values to version control**
- ⚠️ Use different keys and secrets for dev, staging, and production
- ⚠️ Back up production keys securely
- ⚠️ Store in secure secret management systems (GCP Secret Manager, AWS Secrets Manager, etc.)
- ⚠️ Rotate secrets regularly
- ⚠️ Use environment-specific configurations for production

## Sensitive Information

Sensitive information such as API keys and passwords should never be committed to version control. Instead:

1. Use placeholder values in `.env.example`
2. Document the required variables in the [Environment Setup Guide](../environment-setup.mdx)
3. Use secrets management in production environments
