import { CodeBlock } from '@/components/CodeBlock'

# Custom Tools

Extend Penelope's capabilities by creating custom tools for specialized testing needs.

## Tool Interface

All tools implement the `Tool` abstract base class:

<CodeBlock filename="tool_interface.py" language="python">
{`from abc import ABC, abstractmethod
from rhesis.penelope.tools.base import Tool, ToolResult

class Tool(ABC):
    @property
    @abstractmethod
    def name(self) -> str:
        """Unique identifier for the tool"""
        pass
    
    @property
    @abstractmethod
    def description(self) -> str:
        """Detailed description with usage guidance"""
        pass
    
    @abstractmethod
    def execute(self, **kwargs) -> ToolResult:
        """Execute the tool with validated parameters"""
        pass`}
</CodeBlock>

<Callout type="info">
  **Parameter Validation:** Tool parameters are automatically validated via Pydantic schemas. Your `execute` method receives validated inputs.
</Callout>

## Creating a Custom Tool

### Example: Database Verification Tool

<CodeBlock filename="database_tool.py" language="python">
{`from rhesis.penelope.tools.base import Tool, ToolResult
import sqlite3

class DatabaseVerificationTool(Tool):
    def __init__(self, db_path: str):
        self.db_path = db_path
    
    @property
    def name(self) -> str:
        return "verify_database_state"
    
    @property
    def description(self) -> str:
        return """Verify backend database state during testing.

WHEN TO USE:
✓ Check if data was saved correctly
✓ Validate database state changes
✓ Verify data consistency

PARAMETERS:
- table_name: Database table to query
- record_id: Specific record ID to verify

EXAMPLE:
verify_database_state(
    table_name="users",
    record_id="user123"
)

Returns record data or error if not found."""
    
    def execute(self, table_name: str = "", record_id: str = "", **kwargs) -> ToolResult:
        if not table_name or not record_id:
            return ToolResult(
                success=False,
                output={"error": "table_name and record_id required"}
            )
        
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            cursor.execute(
                f"SELECT * FROM {table_name} WHERE id = ?",
                (record_id,)
            )
            result = cursor.fetchone()
            conn.close()
            
            if result:
                return ToolResult(
                    success=True,
                    output={
                        "found": True,
                        "record": dict(result),
                        "table": table_name
                    }
                )
            else:
                return ToolResult(
                    success=True,
                    output={
                        "found": False,
                        "message": f"No record found with id {record_id}"
                    }
                )
        except Exception as e:
            return ToolResult(
                success=False,
                output={"error": str(e)}
            )`}
</CodeBlock>

### Using Your Custom Tool

<CodeBlock filename="use_custom_tool.py" language="python">
{`from rhesis.penelope import PenelopeAgent, EndpointTarget

# Create tool instance
db_tool = DatabaseVerificationTool(db_path="test.db")

# Initialize agent with custom tool
agent = PenelopeAgent(
    tools=[db_tool],
    enable_transparency=True
)

# Execute test - Penelope can now use the database tool
result = agent.execute_test(
    target=EndpointTarget(endpoint_id="your-endpoint-id"),
    goal="Verify chatbot correctly saves user preferences to database",
    instructions="""
    1. Ask chatbot to save a preference
    2. Use verify_database_state to check if it was saved
    3. Verify the saved data matches what was requested
    """
)`}
</CodeBlock>

## Writing Quality Tool Descriptions

Good descriptions help Penelope understand when and how to use your tool:

### Key Elements

1. **Purpose** - What the tool does
2. **When to Use** - Scenarios for using this tool
3. **When NOT to Use** - Scenarios to avoid
4. **Parameters** - Expected inputs with types
5. **Examples** - Real usage examples
6. **Important Notes** - Caveats and limitations

<CodeBlock filename="good_description.py" language="python">
{`@property
def description(self) -> str:
    return """[PURPOSE] Check API endpoint health and response times.

WHEN TO USE:
✓ Verify system is responding
✓ Check performance degradation
✓ Validate API availability

WHEN NOT TO USE:
✗ Don't use for data retrieval
✗ Don't use for authentication checks

PARAMETERS:
- endpoint_url: Full URL to check (string, required)
- timeout_seconds: Request timeout (int, default: 5)

EXAMPLE:
check_api_health(
    endpoint_url="https://api.example.com/health",
    timeout_seconds=10
)

Returns: {"status": "ok", "response_time_ms": 145}

IMPORTANT:
- Only checks public endpoints
- Does not include authentication headers"""`}
</CodeBlock>

## Multiple Custom Tools

Add multiple tools for comprehensive testing:

<CodeBlock filename="multiple_tools.py" language="python">
{`# Define multiple specialized tools
db_tool = DatabaseVerificationTool(db_path="test.db")
api_tool = APIMonitoringTool(base_url="https://api.example.com")
security_tool = SecurityScannerTool()

# Agent can use all tools
agent = PenelopeAgent(
    tools=[db_tool, api_tool, security_tool],
    enable_transparency=True,
    max_iterations=20
)

# Complex test using multiple tools
result = agent.execute_test(
    target=target,
    goal="Comprehensive system validation",
    instructions="""
    1. Verify API is responding (use check_api_health)
    2. Test chatbot functionality
    3. Check database state (use verify_database_state)
    4. Run security scan (use run_security_scan)
    """
)`}
</CodeBlock>

## Best Practices

### 1. Clear Naming

Use descriptive, action-oriented names:

<CodeBlock filename="naming.py" language="python">
{`# Good
"verify_database_state"
"check_api_health"
"validate_user_permissions"

# Bad
"db_tool"
"api"
"check"`}
</CodeBlock>

### 2. Handle Errors Gracefully

<CodeBlock filename="error_handling.py" language="python">
{`def execute(self, **kwargs) -> ToolResult:
    try:
        # Your logic
        result = perform_operation()
        return ToolResult(success=True, output=result)
    except ValueError as e:
        return ToolResult(
            success=False,
            output={"error": f"Invalid input: {e}"}
        )
    except Exception as e:
        return ToolResult(
            success=False,
            output={"error": f"Unexpected error: {e}"}
        )`}
</CodeBlock>

### 3. Provide Rich Output

Return structured, informative data:

<CodeBlock filename="rich_output.py" language="python">
{`# Good - structured and informative
return ToolResult(
    success=True,
    output={
        "status": "healthy",
        "response_time_ms": 145,
        "timestamp": "2024-01-15T10:30:00Z",
        "details": {"version": "1.2.3", "uptime": "5d 3h"}
    }
)

# Bad - minimal information
return ToolResult(success=True, output="ok")`}
</CodeBlock>

### 4. Test Your Tools

Write unit tests for custom tools:

<CodeBlock filename="test_custom_tool.py" language="python">
{`import pytest
from my_tools import DatabaseVerificationTool

def test_database_tool_success():
    tool = DatabaseVerificationTool(db_path="test.db")
    result = tool.execute(table_name="users", record_id="123")
    
    assert result.success is True
    assert result.output["found"] is True
    assert "record" in result.output

def test_database_tool_missing_params():
    tool = DatabaseVerificationTool(db_path="test.db")
    result = tool.execute(table_name="", record_id="")
    
    assert result.success is False
    assert "error" in result.output`}
</CodeBlock>

## Real-World Examples

See complete custom tool implementations in the [examples directory](https://github.com/rhesis-ai/rhesis/tree/main/penelope/examples):

- **custom_tools.py** - Database verification, API monitoring, security scanning
- **batch_testing.py** - Batch test runner tool
- **platform_integration.py** - TestSet loader tool

---

<Callout type="default">
  **Next:** Check out [Examples](/penelope/examples) to see custom tools in action, or review [Architecture](/penelope/architecture) to understand how tools fit into Penelope's design.
</Callout>
